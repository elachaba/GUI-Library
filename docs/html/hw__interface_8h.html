<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Projet C - Interaction Graphique: hw_interface.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Projet C - Interaction Graphique
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0188a3e6da905bc60aceb35bf790b8c9.html">api</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hw_interface.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Low level interface with the graphic hardware. This interface is based on the SDL library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ei__types_8h_source.html">ei_types.h</a>&quot;</code><br />
</div>
<p><a href="hw__interface_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad9970ae727c438faaf09c58c5defb796"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a></td></tr>
<tr class="memdesc:ad9970ae727c438faaf09c58c5defb796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface hidden type. A surface represents a 2 dimensional array of pixels where drawing can be done. What is visible on screen is represented by the surface created by <a class="el" href="hw__interface_8h.html#aa012ef4374709eeb3fe5af60324e8dd7">hw_create_window</a>. Other "offscreen" surfaces can be created by <a class="el" href="hw__interface_8h.html#a20b18780e7aac3439a983a8fa0464c03">hw_surface_create</a>. Surfaces containing text and images are created by <a class="el" href="hw__interface_8h.html#a6371770302e78d3651c792ed87468e8a">hw_text_create_surface</a> and <a class="el" href="hw__interface_8h.html#aeed5af6ddb524c645fb276649a83f462">hw_image_load</a>.  <a href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">More...</a><br /></td></tr>
<tr class="separator:ad9970ae727c438faaf09c58c5defb796"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae58df14f30461cb37e8607aca5522846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#ae58df14f30461cb37e8607aca5522846">hw_init</a> (void)</td></tr>
<tr class="memdesc:ae58df14f30461cb37e8607aca5522846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises access to the low-level operating system services. <em>Must</em> be called (only once) before any other calls to the hardware interface.  <a href="hw__interface_8h.html#ae58df14f30461cb37e8607aca5522846">More...</a><br /></td></tr>
<tr class="separator:ae58df14f30461cb37e8607aca5522846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4354544a70c108fe5d8f17c69a2874"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#abe4354544a70c108fe5d8f17c69a2874">hw_quit</a> (void)</td></tr>
<tr class="memdesc:abe4354544a70c108fe5d8f17c69a2874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the access to the low-level operating system services and releases resources.  <a href="hw__interface_8h.html#abe4354544a70c108fe5d8f17c69a2874">More...</a><br /></td></tr>
<tr class="separator:abe4354544a70c108fe5d8f17c69a2874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa012ef4374709eeb3fe5af60324e8dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#aa012ef4374709eeb3fe5af60324e8dd7">hw_create_window</a> (<a class="el" href="structei__size__t.html">ei_size_t</a> size, bool fullScreen)</td></tr>
<tr class="memdesc:aa012ef4374709eeb3fe5af60324e8dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the main graphical window of the application.  <a href="hw__interface_8h.html#aa012ef4374709eeb3fe5af60324e8dd7">More...</a><br /></td></tr>
<tr class="separator:aa012ef4374709eeb3fe5af60324e8dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b18780e7aac3439a983a8fa0464c03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a20b18780e7aac3439a983a8fa0464c03">hw_surface_create</a> (const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> root, <a class="el" href="structei__size__t.html">ei_size_t</a> size, bool force_alpha)</td></tr>
<tr class="memdesc:a20b18780e7aac3439a983a8fa0464c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an off-screen drawing surface.  <a href="hw__interface_8h.html#a20b18780e7aac3439a983a8fa0464c03">More...</a><br /></td></tr>
<tr class="separator:a20b18780e7aac3439a983a8fa0464c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d0cca63330b33140dd40288ae1022b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr class="memdesc:a97d0cca63330b33140dd40288ae1022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a surface allocated by <a class="el" href="hw__interface_8h.html#a20b18780e7aac3439a983a8fa0464c03">hw_surface_create</a>. This must be called on an unlocked surface (see <a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>).  <a href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">More...</a><br /></td></tr>
<tr class="separator:a97d0cca63330b33140dd40288ae1022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9b22f29bb9de0b39ea904fd66251be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr class="memdesc:a1b9b22f29bb9de0b39ea904fd66251be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gains exclusive access to a surface. Every call to this function must be matched by a call to <a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>. The address of the pixel buffer may change while the surface is unlocked. Thus, <a class="el" href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">hw_surface_get_buffer</a> must called after each call to this function.  <a href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">More...</a><br /></td></tr>
<tr class="separator:a1b9b22f29bb9de0b39ea904fd66251be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4681e5ead295ccf5b3df3ec8adab66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr class="memdesc:abf4681e5ead295ccf5b3df3ec8adab66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the exclusive access to a surface that was locked by <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>.  <a href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">More...</a><br /></td></tr>
<tr class="separator:abf4681e5ead295ccf5b3df3ec8adab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa41442ed6ec84a120734f7c4fca9a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a6fa41442ed6ec84a120734f7c4fca9a3">hw_surface_update_rects</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface, const <a class="el" href="structei__linked__rect__t.html">ei_linked_rect_t</a> *rects)</td></tr>
<tr class="memdesc:a6fa41442ed6ec84a120734f7c4fca9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that a list of rectangular regions of the root surface be updated on screen.  <a href="hw__interface_8h.html#a6fa41442ed6ec84a120734f7c4fca9a3">More...</a><br /></td></tr>
<tr class="separator:a6fa41442ed6ec84a120734f7c4fca9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8e86abad6a3f16317d74e541d5034d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#afd8e86abad6a3f16317d74e541d5034d">hw_surface_get_channel_indices</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface, int *ir, int *ig, int *ib, int *ia)</td></tr>
<tr class="memdesc:afd8e86abad6a3f16317d74e541d5034d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the R, G, B, and Alpha channel indices of a surface. For example, if *ir is 2, this means that the red channel is stored at the address of the (4 bytes) pixel plus two. *ia may be -1, this means that the surface does not handle alpha.  <a href="hw__interface_8h.html#afd8e86abad6a3f16317d74e541d5034d">More...</a><br /></td></tr>
<tr class="separator:afd8e86abad6a3f16317d74e541d5034d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfe7b0284f7d6dad28541d49714faf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a5bfe7b0284f7d6dad28541d49714faf7">hw_surface_set_origin</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface, const <a class="el" href="structei__point__t.html">ei_point_t</a> origin)</td></tr>
<tr class="memdesc:a5bfe7b0284f7d6dad28541d49714faf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the coordinates of the first pixel of the surface's memory. By default, the coordinates of the first pixel are (0, 0). This can be changed by a call to this function. After a call to this function, the function <a class="el" href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">hw_surface_get_buffer</a> returns a different address than before.  <a href="hw__interface_8h.html#a5bfe7b0284f7d6dad28541d49714faf7">More...</a><br /></td></tr>
<tr class="separator:a5bfe7b0284f7d6dad28541d49714faf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8942e332c58a06edd0e639e6743532d1"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">hw_surface_get_buffer</a> (const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr class="memdesc:a8942e332c58a06edd0e639e6743532d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the address of the pixel at coordinated (0, 0) of a surface. This is usually the first pixel of the surface's memory. But after a call to <a class="el" href="hw__interface_8h.html#a5bfe7b0284f7d6dad28541d49714faf7">hw_surface_set_origin</a>, the (0, 0) pixel may point within the surface memory or not. Pixels are ordered by horizontal lines, from top to bottom, and from left to right within lines. The pixel buffer of a surface may be moved when the surface is unlocked (<a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>), you must thus call this function after each call to <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>.  <a href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">More...</a><br /></td></tr>
<tr class="separator:a8942e332c58a06edd0e639e6743532d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b92235ad70d5017c843c66affccdcd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structei__size__t.html">ei_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a7b92235ad70d5017c843c66affccdcd2">hw_surface_get_size</a> (const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr class="memdesc:a7b92235ad70d5017c843c66affccdcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a surface.  <a href="hw__interface_8h.html#a7b92235ad70d5017c843c66affccdcd2">More...</a><br /></td></tr>
<tr class="separator:a7b92235ad70d5017c843c66affccdcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca488fe7d5e254ffa9d9e332ee76996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structei__rect__t.html">ei_rect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a6ca488fe7d5e254ffa9d9e332ee76996">hw_surface_get_rect</a> (const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr class="memdesc:a6ca488fe7d5e254ffa9d9e332ee76996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rectangle of a surface (origin and size).  <a href="hw__interface_8h.html#a6ca488fe7d5e254ffa9d9e332ee76996">More...</a><br /></td></tr>
<tr class="separator:a6ca488fe7d5e254ffa9d9e332ee76996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99322fd87f28b843dbf722b41d9ffcfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a99322fd87f28b843dbf722b41d9ffcfc">hw_surface_has_alpha</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr class="memdesc:a99322fd87f28b843dbf722b41d9ffcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if a surface manages transparency, i.e. if the surface has an alpha channel.  <a href="hw__interface_8h.html#a99322fd87f28b843dbf722b41d9ffcfc">More...</a><br /></td></tr>
<tr class="separator:a99322fd87f28b843dbf722b41d9ffcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a92497e03818dbb284c192943928ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a48a92497e03818dbb284c192943928ea">hw_text_font_create</a> (<a class="el" href="ei__types_8h.html#a54e9efab809a177e0b5df09529a6d32c">ei_const_string_t</a> filename, <a class="el" href="ei__types_8h.html#a2438d9879374e1d4805231e9e407bbae">ei_fontstyle_t</a> style, int size)</td></tr>
<tr class="memdesc:a48a92497e03818dbb284c192943928ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a font that can be used to render text. The font must be freed by calling <a class="el" href="hw__interface_8h.html#a2ac46d37db4c40adc10e3afb137f9f02">hw_text_font_free</a>.  <a href="hw__interface_8h.html#a48a92497e03818dbb284c192943928ea">More...</a><br /></td></tr>
<tr class="separator:a48a92497e03818dbb284c192943928ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac46d37db4c40adc10e3afb137f9f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a2ac46d37db4c40adc10e3afb137f9f02">hw_text_font_free</a> (<a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a> font)</td></tr>
<tr class="memdesc:a2ac46d37db4c40adc10e3afb137f9f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a font created by <a class="el" href="hw__interface_8h.html#a48a92497e03818dbb284c192943928ea">hw_text_font_create</a>.  <a href="hw__interface_8h.html#a2ac46d37db4c40adc10e3afb137f9f02">More...</a><br /></td></tr>
<tr class="separator:a2ac46d37db4c40adc10e3afb137f9f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad615725db9a7ae632bb371cc2846b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a5ad615725db9a7ae632bb371cc2846b5">hw_text_compute_size</a> (<a class="el" href="ei__types_8h.html#a54e9efab809a177e0b5df09529a6d32c">ei_const_string_t</a> <a class="el" href="structtext.html">text</a>, const <a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a> font, int *width, int *height)</td></tr>
<tr class="memdesc:a5ad615725db9a7ae632bb371cc2846b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the size of a text surface given the font and the text.  <a href="hw__interface_8h.html#a5ad615725db9a7ae632bb371cc2846b5">More...</a><br /></td></tr>
<tr class="separator:a5ad615725db9a7ae632bb371cc2846b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6371770302e78d3651c792ed87468e8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a6371770302e78d3651c792ed87468e8a">hw_text_create_surface</a> (<a class="el" href="ei__types_8h.html#a54e9efab809a177e0b5df09529a6d32c">ei_const_string_t</a> <a class="el" href="structtext.html">text</a>, const <a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a> font, <a class="el" href="structei__color__t.html">ei_color_t</a> color)</td></tr>
<tr class="memdesc:a6371770302e78d3651c792ed87468e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a surface containing a text. The size of the created surface is just big enough to contain the text. The caller is responsible to release this surface (<a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>) when it is no more needed. WARNING! transparency must be handled when using the returned surface, as explained in the return parameter below.  <a href="hw__interface_8h.html#a6371770302e78d3651c792ed87468e8a">More...</a><br /></td></tr>
<tr class="separator:a6371770302e78d3651c792ed87468e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed5af6ddb524c645fb276649a83f462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#aeed5af6ddb524c645fb276649a83f462">hw_image_load</a> (<a class="el" href="ei__types_8h.html#a54e9efab809a177e0b5df09529a6d32c">ei_const_string_t</a> filename, <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> channels)</td></tr>
<tr class="memdesc:aeed5af6ddb524c645fb276649a83f462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a surface and loads into it an image read from a file. The caller is responsible to release this surface (<a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>) when it is no more needed.  <a href="hw__interface_8h.html#aeed5af6ddb524c645fb276649a83f462">More...</a><br /></td></tr>
<tr class="separator:aeed5af6ddb524c645fb276649a83f462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512ddccf5f945ac12df4b5e226b2a974"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">hw_event_wait_next</a> (struct <a class="el" href="structei__event__t.html">ei_event_t</a> *event)</td></tr>
<tr class="memdesc:a512ddccf5f945ac12df4b5e226b2a974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets this process sleep until a new event is available.  <a href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">More...</a><br /></td></tr>
<tr class="separator:a512ddccf5f945ac12df4b5e226b2a974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02874bbb73186eb6036b15297a12aa7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a02874bbb73186eb6036b15297a12aa7e">hw_event_post_app</a> (<a class="el" href="ei__types_8h.html#a851d40b095b5bf6f3b8733f0a09c820b">ei_user_param_t</a> user_param)</td></tr>
<tr class="memdesc:a02874bbb73186eb6036b15297a12aa7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an application-generated event on the event queue. This will cause <a class="el" href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">hw_event_wait_next</a> to wake.  <a href="hw__interface_8h.html#a02874bbb73186eb6036b15297a12aa7e">More...</a><br /></td></tr>
<tr class="separator:a02874bbb73186eb6036b15297a12aa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad164e1688cc1abf4f5f211853048d63d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#ad164e1688cc1abf4f5f211853048d63d">hw_event_schedule_app</a> (int ms_delay, <a class="el" href="ei__types_8h.html#a851d40b095b5bf6f3b8733f0a09c820b">ei_user_param_t</a> user_param)</td></tr>
<tr class="memdesc:ad164e1688cc1abf4f5f211853048d63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an application-generated event to be posted after some amount of time. This will cause <a class="el" href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">hw_event_wait_next</a> to wake after this amount of time.  <a href="hw__interface_8h.html#ad164e1688cc1abf4f5f211853048d63d">More...</a><br /></td></tr>
<tr class="separator:ad164e1688cc1abf4f5f211853048d63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043d1f7a4ca94cc0b7234fae2b0f2ace"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a043d1f7a4ca94cc0b7234fae2b0f2ace">hw_now</a> (void)</td></tr>
<tr class="memdesc:a043d1f7a4ca94cc0b7234fae2b0f2ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current time, in seconds, from some arbitrary origin. Can be used to measure elapsed time between to calls.  <a href="hw__interface_8h.html#a043d1f7a4ca94cc0b7234fae2b0f2ace">More...</a><br /></td></tr>
<tr class="separator:a043d1f7a4ca94cc0b7234fae2b0f2ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Low level interface with the graphic hardware. This interface is based on the SDL library. </p>
<p>Created by François Bérard on 30.12.11. Copyright 2011 Ensimag. All rights reserved. </p>

<p class="definition">Definition in file <a class="el" href="hw__interface_8h_source.html">hw_interface.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad9970ae727c438faaf09c58c5defb796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9970ae727c438faaf09c58c5defb796">&#9670;&nbsp;</a></span>ei_surface_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Surface hidden type. A surface represents a 2 dimensional array of pixels where drawing can be done. What is visible on screen is represented by the surface created by <a class="el" href="hw__interface_8h.html#aa012ef4374709eeb3fe5af60324e8dd7">hw_create_window</a>. Other "offscreen" surfaces can be created by <a class="el" href="hw__interface_8h.html#a20b18780e7aac3439a983a8fa0464c03">hw_surface_create</a>. Surfaces containing text and images are created by <a class="el" href="hw__interface_8h.html#a6371770302e78d3651c792ed87468e8a">hw_text_create_surface</a> and <a class="el" href="hw__interface_8h.html#aeed5af6ddb524c645fb276649a83f462">hw_image_load</a>. </p>

<p class="definition">Definition at line <a class="el" href="hw__interface_8h_source.html#l00028">28</a> of file <a class="el" href="hw__interface_8h_source.html">hw_interface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa012ef4374709eeb3fe5af60324e8dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa012ef4374709eeb3fe5af60324e8dd7">&#9670;&nbsp;</a></span>hw_create_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> hw_create_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structei__size__t.html">ei_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fullScreen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the main graphical window of the application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of horizontal and vertical pixels. </td></tr>
    <tr><td class="paramname">fullScreen</td><td>If true, opens the window in full screen. Otherwise opens a floating window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unlocked drawing surface (see <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>). This surface should not be freed by calling hw_surface_free: it is freed when releasing access to the low-level services by calling <a class="el" href="hw__interface_8h.html#abe4354544a70c108fe5d8f17c69a2874">hw_quit</a>. </dd></dl>

</div>
</div>
<a id="a02874bbb73186eb6036b15297a12aa7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02874bbb73186eb6036b15297a12aa7e">&#9670;&nbsp;</a></span>hw_event_post_app()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hw_event_post_app </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a851d40b095b5bf6f3b8733f0a09c820b">ei_user_param_t</a>&#160;</td>
          <td class="paramname"><em>user_param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an application-generated event on the event queue. This will cause <a class="el" href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">hw_event_wait_next</a> to wake. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_param</td><td>The user parameter that will be retrievable in the event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad164e1688cc1abf4f5f211853048d63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad164e1688cc1abf4f5f211853048d63d">&#9670;&nbsp;</a></span>hw_event_schedule_app()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_event_schedule_app </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a851d40b095b5bf6f3b8733f0a09c820b">ei_user_param_t</a>&#160;</td>
          <td class="paramname"><em>user_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule an application-generated event to be posted after some amount of time. This will cause <a class="el" href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">hw_event_wait_next</a> to wake after this amount of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms_delay</td><td>The amount of time, in milliseconds, to wait before the event is posted in the event queue. </td></tr>
    <tr><td class="paramname">user_param</td><td>The user parameter that will be retrievable in the event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a512ddccf5f945ac12df4b5e226b2a974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512ddccf5f945ac12df4b5e226b2a974">&#9670;&nbsp;</a></span>hw_event_wait_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_event_wait_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structei__event__t.html">ei_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lets this process sleep until a new event is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Where to store the new event. The structure must be allocated by the caller. On return, the structure is filled with information about the new event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeed5af6ddb524c645fb276649a83f462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed5af6ddb524c645fb276649a83f462">&#9670;&nbsp;</a></span>hw_image_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> hw_image_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a54e9efab809a177e0b5df09529a6d32c">ei_const_string_t</a>&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a surface and loads into it an image read from a file. The caller is responsible to release this surface (<a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>) when it is no more needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file containing the image. The file can be .png, .tiff, .jpg, etc. </td></tr>
    <tr><td class="paramname">channels</td><td>A surface to define channel ordering: the newly created surface that is returned by this function will have the same channel order as this surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new unlocked surface containing the image. </dd></dl>

</div>
</div>
<a id="ae58df14f30461cb37e8607aca5522846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58df14f30461cb37e8607aca5522846">&#9670;&nbsp;</a></span>hw_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises access to the low-level operating system services. <em>Must</em> be called (only once) before any other calls to the hardware interface. </p>

</div>
</div>
<a id="a043d1f7a4ca94cc0b7234fae2b0f2ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043d1f7a4ca94cc0b7234fae2b0f2ace">&#9670;&nbsp;</a></span>hw_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hw_now </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current time, in seconds, from some arbitrary origin. Can be used to measure elapsed time between to calls. </p>
<dl class="section return"><dt>Returns</dt><dd>The current time, in seconds. </dd></dl>

</div>
</div>
<a id="abe4354544a70c108fe5d8f17c69a2874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4354544a70c108fe5d8f17c69a2874">&#9670;&nbsp;</a></span>hw_quit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_quit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the access to the low-level operating system services and releases resources. </p>

</div>
</div>
<a id="a20b18780e7aac3439a983a8fa0464c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b18780e7aac3439a983a8fa0464c03">&#9670;&nbsp;</a></span>hw_surface_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> hw_surface_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structei__size__t.html">ei_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an off-screen drawing surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The root window which channel indices will be used. This insures that the offscreen uses the same channel indices (Red, Green, Blue, Alpha) as the root surface. </td></tr>
    <tr><td class="paramname">size</td><td>Number of horizontal and vertical pixels. </td></tr>
    <tr><td class="paramname">force_alpha</td><td>If true, then the returned surface will use an alpha channel regardless of root having an alpha channel or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unlocked drawing surface (see <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>). The surface should be freed by calling <a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>. </dd></dl>

</div>
</div>
<a id="a97d0cca63330b33140dd40288ae1022b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d0cca63330b33140dd40288ae1022b">&#9670;&nbsp;</a></span>hw_surface_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a surface allocated by <a class="el" href="hw__interface_8h.html#a20b18780e7aac3439a983a8fa0464c03">hw_surface_create</a>. This must be called on an unlocked surface (see <a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The surface to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8942e332c58a06edd0e639e6743532d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8942e332c58a06edd0e639e6743532d1">&#9670;&nbsp;</a></span>hw_surface_get_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* hw_surface_get_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the address of the pixel at coordinated (0, 0) of a surface. This is usually the first pixel of the surface's memory. But after a call to <a class="el" href="hw__interface_8h.html#a5bfe7b0284f7d6dad28541d49714faf7">hw_surface_set_origin</a>, the (0, 0) pixel may point within the surface memory or not. Pixels are ordered by horizontal lines, from top to bottom, and from left to right within lines. The pixel buffer of a surface may be moved when the surface is unlocked (<a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>), you must thus call this function after each call to <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The surface from which the pixel address is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd8e86abad6a3f16317d74e541d5034d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8e86abad6a3f16317d74e541d5034d">&#9670;&nbsp;</a></span>hw_surface_get_channel_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_get_channel_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ia</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the R, G, B, and Alpha channel indices of a surface. For example, if *ir is 2, this means that the red channel is stored at the address of the (4 bytes) pixel plus two. *ia may be -1, this means that the surface does not handle alpha. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The surface. </td></tr>
    <tr><td class="paramname">ir,ig,ib,ia</td><td>Where to store the resulting indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ca488fe7d5e254ffa9d9e332ee76996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca488fe7d5e254ffa9d9e332ee76996">&#9670;&nbsp;</a></span>hw_surface_get_rect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structei__rect__t.html">ei_rect_t</a> hw_surface_get_rect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rectangle of a surface (origin and size). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The surface which rectangle is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rectangle of the surface. </dd></dl>

</div>
</div>
<a id="a7b92235ad70d5017c843c66affccdcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b92235ad70d5017c843c66affccdcd2">&#9670;&nbsp;</a></span>hw_surface_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structei__size__t.html">ei_size_t</a> hw_surface_get_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of a surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The surface which size is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the surface. </dd></dl>

</div>
</div>
<a id="a99322fd87f28b843dbf722b41d9ffcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99322fd87f28b843dbf722b41d9ffcfc">&#9670;&nbsp;</a></span>hw_surface_has_alpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hw_surface_has_alpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if a surface manages transparency, i.e. if the surface has an alpha channel. </p>
<dl class="section return"><dt>Returns</dt><dd>A boolean: true means that the surface has an alpha (transparency) channel, false means it does not. </dd></dl>

</div>
</div>
<a id="a1b9b22f29bb9de0b39ea904fd66251be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9b22f29bb9de0b39ea904fd66251be">&#9670;&nbsp;</a></span>hw_surface_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gains exclusive access to a surface. Every call to this function must be matched by a call to <a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>. The address of the pixel buffer may change while the surface is unlocked. Thus, <a class="el" href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">hw_surface_get_buffer</a> must called after each call to this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The surface to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bfe7b0284f7d6dad28541d49714faf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfe7b0284f7d6dad28541d49714faf7">&#9670;&nbsp;</a></span>hw_surface_set_origin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_set_origin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structei__point__t.html">ei_point_t</a>&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the coordinates of the first pixel of the surface's memory. By default, the coordinates of the first pixel are (0, 0). This can be changed by a call to this function. After a call to this function, the function <a class="el" href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">hw_surface_get_buffer</a> returns a different address than before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The surface which origin must be changed. </td></tr>
    <tr><td class="paramname">origin</td><td>The new coordinates of the first pixel of the surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf4681e5ead295ccf5b3df3ec8adab66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4681e5ead295ccf5b3df3ec8adab66">&#9670;&nbsp;</a></span>hw_surface_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the exclusive access to a surface that was locked by <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The surface to unlock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fa41442ed6ec84a120734f7c4fca9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa41442ed6ec84a120734f7c4fca9a3">&#9670;&nbsp;</a></span>hw_surface_update_rects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_update_rects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structei__linked__rect__t.html">ei_linked_rect_t</a> *&#160;</td>
          <td class="paramname"><em>rects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests that a list of rectangular regions of the root surface be updated on screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The surface returned by <a class="el" href="hw__interface_8h.html#aa012ef4374709eeb3fe5af60324e8dd7">hw_create_window</a>. This function can only be called on <em>unlocked surfaces</em> (<a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>). </td></tr>
    <tr><td class="paramname">rects</td><td>The list of rectangle to be updated on screen. If NULL, them the entire surface is updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ad615725db9a7ae632bb371cc2846b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad615725db9a7ae632bb371cc2846b5">&#9670;&nbsp;</a></span>hw_text_compute_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_text_compute_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a54e9efab809a177e0b5df09529a6d32c">ei_const_string_t</a>&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a>&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the size of a text surface given the font and the text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string of the message. </td></tr>
    <tr><td class="paramname">font</td><td>The font used to render the text. </td></tr>
    <tr><td class="paramname">width,height</td><td>Addresses where to store the computed width and height of the text surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6371770302e78d3651c792ed87468e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6371770302e78d3651c792ed87468e8a">&#9670;&nbsp;</a></span>hw_text_create_surface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> hw_text_create_surface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a54e9efab809a177e0b5df09529a6d32c">ei_const_string_t</a>&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a>&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structei__color__t.html">ei_color_t</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a surface containing a text. The size of the created surface is just big enough to contain the text. The caller is responsible to release this surface (<a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>) when it is no more needed. WARNING! transparency must be handled when using the returned surface, as explained in the return parameter below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string of the message. </td></tr>
    <tr><td class="paramname">font</td><td>The font used to render the text. </td></tr>
    <tr><td class="paramname">color</td><td>The text color. The alpha parameter is not used. However, the text is rendered with alpha blending to smooth the curves of the letters (anti-aliasing).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created unlocked surface containing an anti-aliased rendering of the text. The anti-aliasing is implemented with the alpha channel of the surface: all pixels have the same color. Background pixels are transparent, interior pixels are opaque, pixels at letters' boundary have some transparency. </dd></dl>

</div>
</div>
<a id="a48a92497e03818dbb284c192943928ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a92497e03818dbb284c192943928ea">&#9670;&nbsp;</a></span>hw_text_font_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a> hw_text_font_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a54e9efab809a177e0b5df09529a6d32c">ei_const_string_t</a>&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a2438d9879374e1d4805231e9e407bbae">ei_fontstyle_t</a>&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a font that can be used to render text. The font must be freed by calling <a class="el" href="hw__interface_8h.html#a2ac46d37db4c40adc10e3afb137f9f02">hw_text_font_free</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The path to the file containing the ttf font definition. Can be relative. </td></tr>
    <tr><td class="paramname">style</td><td>The style of the font (normal, bold, ...). </td></tr>
    <tr><td class="paramname">size</td><td>The size of the characters in pixels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The font. </dd></dl>

</div>
</div>
<a id="a2ac46d37db4c40adc10e3afb137f9f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac46d37db4c40adc10e3afb137f9f02">&#9670;&nbsp;</a></span>hw_text_font_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_text_font_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a>&#160;</td>
          <td class="paramname"><em>font</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a font created by <a class="el" href="hw__interface_8h.html#a48a92497e03818dbb284c192943928ea">hw_text_font_create</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">font</td><td>The font to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 24 2023 03:02:27 for Projet C - Interaction Graphique by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
